#!/usr/bin/env python3

import argparse

ap = argparse.ArgumentParser()
ap.add_argument('--quiet', '-q', action='store_true')
ap.add_argument('--configfile')
ap.add_argument('time')
ap.add_argument('message', nargs='*', default='Timer')
args = ap.parse_args()

if isinstance(args.message, list):
    args.message = ' '.join(args.message)

# "time" can be:
# A fixed time (in the next 24 hours):
#   20:15
#   20:15:03
#
# A time span
#   10min
#   10m
#   15s
#   1h10m30s
#   3d

import re, datetime, subprocess, configparser, shlex, os.path, sys

re_date = r'(?:\d\d\d\d-)?\d\d-\d\d'
re_time = r'\d\d?:\d\d(?::\d\d)?'
re_intervalls = r'(?:\d+(?:[smhd]|min|) *)+'
re_timespec = '(?:' + re_intervalls + '|' + re_time + ')'

def parse_delay(s):
    mo_time = re.search('^' + re_time + '$', s)
    mo_intervalls = re.search('^' + re_intervalls + '$', s)

    if mo_time is not None:
        tstr = mo_time.group()
        if len(tstr) == 4:
            tstr = '0' + tstr
        if len(tstr) == 7:
            tstr = '0' + tstr

        if len(tstr) == 5:
            t = datetime.datetime.strptime(mo_time.group(), '%H:%M').time()
        elif len(tstr) == 8:
            t = datetime.datetime.strptime(mo_time.group(), '%H:%M:%S').time()
        d = datetime.date.today()
        target = datetime.datetime.combine(d, t)
        if target < datetime.datetime.now():
            target = datetime.datetime.combine(d + datetime.timedelta(days=1), t)
        return target
    elif mo_intervalls is not None:
        target = datetime.datetime.now()
        for inter in re.split(r'(\d+[^\d]*)', mo_intervalls.group()):
            if inter == '':
                continue
            parts = re.split(r'(\d+)', inter)
            if parts and parts[0] == '':
                del parts[0]
            num = int(parts[0])
            unit = parts[1] if len(parts) > 1 else 'm'
            if unit in ('s',):
                target += datetime.timedelta(seconds=num)
            elif unit in ('m', 'min'):
                target += datetime.timedelta(minutes=num)
            elif unit in ('h',):
                target += datetime.timedelta(hours=num)
            elif unit in ('d',):
                target += datetime.timedelta(days=num)
            else:
                raise ValueError("unknown interval unit: %s" % unit)
        return target
    else:
        raise ValueError("parse error")

try:
    notifytime = parse_delay(args.time)
except ValueError as err:
    print("invalid target time value: %s" % err, file=sys.stderr)
    sys.exit(1)

conf = configparser.RawConfigParser()
conf.read(['/etc/timer.conf', os.path.expanduser('~/.config/timer.conf')])
if args.configfile is not None:
    conf.read(args.configfile)
notifytext_fmt = conf.get('timer', 'message', fallback='[{notifytime:%H:%M}] | {message}')
notifycmd_fmtstr = conf.get('timer', 'notify', fallback='notify-send -u critical "{notifytext}"')

try:
    notifycmd_fmt = shlex.split(notifycmd_fmtstr)
except ValueError as err:
    print("error in 'notify' configuration: %s: %s" % (err, notifycmd_fmtstr), file=sys.stderr)
    sys.exit(1)

try:
    notifytext = notifytext_fmt.format(notifytime=notifytime, message=args.message)
except ValueError as err:
    print("error in 'message' configuration: %s: %s" % (err, notifytext_fmt), file=sys.stderr)
    sys.exit(1)
try:
    notifycmd = [arg.format(notifytext=notifytext, notifytime=notifytime) for arg in notifycmd_fmt]
except ValueError as err:
    print("error in 'notify' configuration: %s: %s" % (err, notifycmd_fmt), file=sys.stderr)
    sys.exit(1)

if not args.quiet:
    print("scheduled for {notifytime:%H:%M}".format(notifytime=notifytime))


# Fork and daemonize
import os, sys
if os.fork() != 0:
    sys.exit(0)
os.setsid()

import time
delay = notifytime - datetime.datetime.now()
if delay > datetime.timedelta(seconds=0):
    time.sleep(delay.total_seconds())
try:
    subprocess.run(notifycmd)
except Exception as err:
    print("failed to run 'notify' command: %s" % err, file=sys.stderr)
    sys.exit(1)
